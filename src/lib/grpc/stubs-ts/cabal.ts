// @generated by protobuf-ts 2.10.0
// @generated from protobuf file "cabal.proto" (package "cabal", syntax proto3)
// tslint:disable
import { DeleteOrders } from "./orders";
import { PlaceLimitOrdersResponce } from "./orders";
import { TokenLimitOrders } from "./orders";
import { TokenAddress } from "./common";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UnixTimestamp } from "./common";
import { QuoteKind } from "./common";
import { LandedTxnState } from "./txncb";
/**
 * @generated from protobuf message cabal.UserAction
 */
export interface UserAction {
    /**
     * @generated from protobuf oneof: user_action_kind
     */
    userActionKind: {
        oneofKind: "buy";
        /**
         * @generated from protobuf field: cabal.Buy buy = 1;
         */
        buy: Buy;
    } | {
        oneofKind: "sell";
        /**
         * @generated from protobuf field: cabal.Sell sell = 2;
         */
        sell: Sell;
    } | {
        oneofKind: "tokenTradeStats";
        /**
         * @generated from protobuf field: cabal.TokenTradeStats token_trade_stats = 3;
         */
        tokenTradeStats: TokenTradeStats;
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: cabal.Ping ping = 4;
         */
        ping: Ping;
    } | {
        oneofKind: "pong";
        /**
         * @generated from protobuf field: cabal.Pong pong = 5;
         */
        pong: Pong;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message cabal.TradeEventSub
 */
export interface TradeEventSub {
}
/**
 * @generated from protobuf message cabal.UserActionSub
 */
export interface UserActionSub {
}
/**
 * @generated from protobuf message cabal.EchoRequest
 */
export interface EchoRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message cabal.EchoResponse
 */
export interface EchoResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message cabal.TradeEventRequest
 */
export interface TradeEventRequest {
    /**
     * @generated from protobuf oneof: trade_event_request_kind
     */
    tradeEventRequestKind: {
        oneofKind: "sub";
        /**
         * @generated from protobuf field: cabal.TokenTradeEventSub sub = 1;
         */
        sub: TokenTradeEventSub;
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: cabal.Ping ping = 2;
         */
        ping: Ping;
    } | {
        oneofKind: "pong";
        /**
         * @generated from protobuf field: cabal.Pong pong = 3;
         */
        pong: Pong;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message cabal.TokenTradeEventSub
 */
export interface TokenTradeEventSub {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
}
/**
 * @generated from protobuf message cabal.TokenStatusRequest
 */
export interface TokenStatusRequest {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
}
/**
 * @generated from protobuf message cabal.TradeEventResponse
 */
export interface TradeEventResponse {
    /**
     * @generated from protobuf oneof: trade_event_response_kind
     */
    tradeEventResponseKind: {
        oneofKind: "tradeEvent";
        /**
         * @generated from protobuf field: cabal.TradeEvent trade_event = 1;
         */
        tradeEvent: TradeEvent;
    } | {
        oneofKind: "tokenStatus";
        /**
         * @generated from protobuf field: cabal.TokenStatus token_status = 2;
         */
        tokenStatus: TokenStatus;
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: cabal.Ping ping = 3;
         */
        ping: Ping;
    } | {
        oneofKind: "pong";
        /**
         * @generated from protobuf field: cabal.Pong pong = 4;
         */
        pong: Pong;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message cabal.Ping
 */
export interface Ping {
    /**
     * @generated from protobuf field: uint64 count = 1;
     */
    count: bigint;
}
/**
 * @generated from protobuf message cabal.Pong
 */
export interface Pong {
    /**
     * @generated from protobuf field: uint64 count = 1;
     */
    count: bigint;
}
/**
 * @generated from protobuf message cabal.UserResponse
 */
export interface UserResponse {
    /**
     * @generated from protobuf oneof: user_response_kind
     */
    userResponseKind: {
        oneofKind: "tradeStatus";
        /**
         * @generated from protobuf field: cabal.TradeResponse trade_status = 1;
         */
        tradeStatus: TradeResponse;
    } | {
        oneofKind: "tradeStats";
        /**
         * @generated from protobuf field: cabal.TokenTradeStats trade_stats = 2;
         */
        tradeStats: TokenTradeStats;
    } | {
        oneofKind: "txnCb";
        /**
         * @generated from protobuf field: txncb.LandedTxnState txn_cb = 3;
         */
        txnCb: LandedTxnState;
    } | {
        oneofKind: "ping";
        /**
         * @generated from protobuf field: cabal.Ping ping = 4;
         */
        ping: Ping;
    } | {
        oneofKind: "pong";
        /**
         * @generated from protobuf field: cabal.Pong pong = 5;
         */
        pong: Pong;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message cabal.TokenTradeStatsCall
 */
export interface TokenTradeStatsCall {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
}
/**
 * @generated from protobuf message cabal.TradeResponse
 */
export interface TradeResponse {
    /**
     * @generated from protobuf field: uint64 slot = 2;
     */
    slot: bigint;
}
/**
 * @generated from protobuf message cabal.TokenStatus
 */
export interface TokenStatus {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
    /**
     * @generated from protobuf field: string pool_id = 2;
     */
    poolId: string;
    /**
     * @generated from protobuf field: cabal.PoolKind pool_kind = 3;
     */
    poolKind: PoolKind;
    /**
     * @generated from protobuf field: cabal.MigrationStatus migration_status = 4;
     */
    migrationStatus: MigrationStatus;
    /**
     * @generated from protobuf field: uint64 supply = 5;
     */
    supply: bigint;
    /**
     * @generated from protobuf field: uint64 base_liq = 6;
     */
    baseLiq: bigint;
    /**
     * @generated from protobuf field: uint64 quote_liq = 7;
     */
    quoteLiq: bigint;
    /**
     * @generated from protobuf field: common.QuoteKind qoute_kind = 8;
     */
    qouteKind: QuoteKind;
    /**
     * @generated from protobuf field: optional uint32 tax_bps = 9;
     */
    taxBps?: number;
    /**
     * @generated from protobuf field: string ticker = 10;
     */
    ticker: string;
}
/**
 * @generated from protobuf message cabal.TokenTradeStats
 */
export interface TokenTradeStats {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
    /**
     * @generated from protobuf field: uint64 token_balance = 2;
     */
    tokenBalance: bigint;
    /**
     * @generated from protobuf field: uint64 buy_qoute = 3;
     */
    buyQoute: bigint;
    /**
     * @generated from protobuf field: uint64 sell_qoute = 4;
     */
    sellQoute: bigint;
    /**
     * @generated from protobuf field: uint64 buy_base = 5;
     */
    buyBase: bigint;
    /**
     * @generated from protobuf field: uint64 sell_base = 6;
     */
    sellBase: bigint;
    /**
     * @generated from protobuf field: uint32 buys = 7;
     */
    buys: number;
    /**
     * @generated from protobuf field: uint32 sells = 8;
     */
    sells: number;
    /**
     * @generated from protobuf field: uint64 sol_balance = 9;
     */
    solBalance: bigint;
    /**
     * @generated from protobuf field: uint64 last_traded_slot = 10;
     */
    lastTradedSlot: bigint;
    /**
     * @generated from protobuf field: uint32 token_decimals = 11;
     */
    tokenDecimals: number;
    /**
     * @generated from protobuf field: common.QuoteKind qoute_kind = 12;
     */
    qouteKind: QuoteKind;
}
/**
 * @generated from protobuf message cabal.TradeEvent
 */
export interface TradeEvent {
    /**
     * @generated from protobuf oneof: trade_event_kind
     */
    tradeEventKind: {
        oneofKind: "buy";
        /**
         * @generated from protobuf field: cabal.TradeEventData buy = 1;
         */
        buy: TradeEventData;
    } | {
        oneofKind: "sell";
        /**
         * @generated from protobuf field: cabal.TradeEventData sell = 2;
         */
        sell: TradeEventData;
    } | {
        oneofKind: "deposit";
        /**
         * @generated from protobuf field: cabal.TradeEventData deposit = 3;
         */
        deposit: TradeEventData;
    } | {
        oneofKind: "withdraw";
        /**
         * @generated from protobuf field: cabal.TradeEventData withdraw = 4;
         */
        withdraw: TradeEventData;
    } | {
        oneofKind: "migrationStart";
        /**
         * @generated from protobuf field: cabal.TradeEventData migration_start = 5;
         */
        migrationStart: TradeEventData;
    } | {
        oneofKind: "migrationEnd";
        /**
         * @generated from protobuf field: cabal.TradeEventData migration_end = 6;
         */
        migrationEnd: TradeEventData;
    } | {
        oneofKind: "burnLiq";
        /**
         * @generated from protobuf field: cabal.BurnEventData burn_liq = 7;
         */
        burnLiq: BurnEventData;
    } | {
        oneofKind: "burnMint";
        /**
         * @generated from protobuf field: cabal.BurnEventData burn_mint = 8;
         */
        burnMint: BurnEventData;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message cabal.TradeEventData
 */
export interface TradeEventData {
    /**
     * @generated from protobuf field: uint64 amount_sol = 1;
     */
    amountSol: bigint;
    /**
     * @generated from protobuf field: uint64 base_liq = 2;
     */
    baseLiq: bigint;
    /**
     * @generated from protobuf field: uint64 quote_liq = 3;
     */
    quoteLiq: bigint;
    /**
     * @generated from protobuf field: cabal.PoolKind pool_kind = 4;
     */
    poolKind: PoolKind;
}
/**
 * @generated from protobuf message cabal.BurnEventData
 */
export interface BurnEventData {
    /**
     * @generated from protobuf field: uint64 amount = 1;
     */
    amount: bigint;
    /**
     * @generated from protobuf field: uint64 left = 2;
     */
    left: bigint;
}
/**
 * @generated from protobuf message cabal.Buy
 */
export interface Buy {
    /**
     * @generated from protobuf field: uint64 amount = 1;
     */
    amount: bigint;
    /**
     * @generated from protobuf field: string mint = 2;
     */
    mint: string;
    /**
     * @generated from protobuf field: uint32 slippage_bps = 3;
     */
    slippageBps: number; // fract 0 - 1
    /**
     * @generated from protobuf field: uint64 tip = 4;
     */
    tip: bigint;
    /**
     * @generated from protobuf field: optional uint64 priority_fee = 5;
     */
    priorityFee?: bigint; // lamports
    /**
     * @generated from protobuf field: optional uint64 nonce = 6;
     */
    nonce?: bigint;
    /**
     * @generated from protobuf field: optional uint32 slot_latency = 7;
     */
    slotLatency?: number;
    /**
     * @generated from protobuf field: optional common.UnixTimestamp expire_at = 8;
     */
    expireAt?: UnixTimestamp; // Utc timestamp in seconds
    /**
     * @generated from protobuf field: optional common.QuoteKind qoute_kind = 9;
     */
    qouteKind?: QuoteKind;
}
/**
 * @generated from protobuf message cabal.Sell
 */
export interface Sell {
    /**
     * @generated from protobuf field: uint32 amount_bps = 1;
     */
    amountBps: number; // fract 0 - 1
    /**
     * @generated from protobuf field: string mint = 2;
     */
    mint: string;
    /**
     * @generated from protobuf field: uint32 slippage_bps = 3;
     */
    slippageBps: number; // fract 0 - 1
    /**
     * @generated from protobuf field: uint64 tip = 4;
     */
    tip: bigint;
    /**
     * @generated from protobuf field: optional uint64 priority_fee = 5;
     */
    priorityFee?: bigint; // lamports
    /**
     * @generated from protobuf field: optional uint64 nonce = 6;
     */
    nonce?: bigint;
    /**
     * @generated from protobuf field: optional uint32 slot_latency = 7;
     */
    slotLatency?: number;
    /**
     * @generated from protobuf field: optional common.UnixTimestamp expire_at = 8;
     */
    expireAt?: UnixTimestamp; // Utc timestamp in seconds
}
/**
 * @generated from protobuf enum cabal.UserTradeStatus
 */
export enum UserTradeStatus {
    /**
     * @generated from protobuf enum value: accepted = 0;
     */
    accepted = 0,
    /**
     * @generated from protobuf enum value: rejected = 1;
     */
    rejected = 1
}
/**
 * @generated from protobuf enum cabal.MigrationStatus
 */
export enum MigrationStatus {
    /**
     * @generated from protobuf enum value: migrated = 0;
     */
    migrated = 0,
    /**
     * @generated from protobuf enum value: migrating = 1;
     */
    migrating = 1,
    /**
     * @generated from protobuf enum value: pre_migration = 2;
     */
    pre_migration = 2,
    /**
     * @generated from protobuf enum value: non_migratable = 3;
     */
    non_migratable = 3
}
/**
 * @generated from protobuf enum cabal.PoolKind
 */
export enum PoolKind {
    /**
     * @generated from protobuf enum value: pump = 0;
     */
    pump = 0,
    /**
     * @generated from protobuf enum value: ray_amm = 1;
     */
    ray_amm = 1,
    /**
     * @generated from protobuf enum value: moonshot = 2;
     */
    moonshot = 2,
    /**
     * @generated from protobuf enum value: meteora = 3;
     */
    meteora = 3,
    /**
     * @generated from protobuf enum value: ray_clmm = 4;
     */
    ray_clmm = 4,
    /**
     * @generated from protobuf enum value: ray_cpmm = 5;
     */
    ray_cpmm = 5,
    /**
     * @generated from protobuf enum value: pump_amm = 6;
     */
    pump_amm = 6,
    /**
     * @generated from protobuf enum value: ray_ll = 7;
     */
    ray_ll = 7
}
// @generated message type with reflection information, may provide speed optimized methods
class UserAction$Type extends MessageType<UserAction> {
    constructor() {
        super("cabal.UserAction", [
            { no: 1, name: "buy", kind: "message", oneof: "userActionKind", T: () => Buy },
            { no: 2, name: "sell", kind: "message", oneof: "userActionKind", T: () => Sell },
            { no: 3, name: "token_trade_stats", kind: "message", oneof: "userActionKind", T: () => TokenTradeStats },
            { no: 4, name: "ping", kind: "message", oneof: "userActionKind", T: () => Ping },
            { no: 5, name: "pong", kind: "message", oneof: "userActionKind", T: () => Pong }
        ]);
    }
    create(value?: PartialMessage<UserAction>): UserAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userActionKind = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UserAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserAction): UserAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cabal.Buy buy */ 1:
                    message.userActionKind = {
                        oneofKind: "buy",
                        buy: Buy.internalBinaryRead(reader, reader.uint32(), options, (message.userActionKind as any).buy)
                    };
                    break;
                case /* cabal.Sell sell */ 2:
                    message.userActionKind = {
                        oneofKind: "sell",
                        sell: Sell.internalBinaryRead(reader, reader.uint32(), options, (message.userActionKind as any).sell)
                    };
                    break;
                case /* cabal.TokenTradeStats token_trade_stats */ 3:
                    message.userActionKind = {
                        oneofKind: "tokenTradeStats",
                        tokenTradeStats: TokenTradeStats.internalBinaryRead(reader, reader.uint32(), options, (message.userActionKind as any).tokenTradeStats)
                    };
                    break;
                case /* cabal.Ping ping */ 4:
                    message.userActionKind = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.userActionKind as any).ping)
                    };
                    break;
                case /* cabal.Pong pong */ 5:
                    message.userActionKind = {
                        oneofKind: "pong",
                        pong: Pong.internalBinaryRead(reader, reader.uint32(), options, (message.userActionKind as any).pong)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cabal.Buy buy = 1; */
        if (message.userActionKind.oneofKind === "buy")
            Buy.internalBinaryWrite(message.userActionKind.buy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Sell sell = 2; */
        if (message.userActionKind.oneofKind === "sell")
            Sell.internalBinaryWrite(message.userActionKind.sell, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TokenTradeStats token_trade_stats = 3; */
        if (message.userActionKind.oneofKind === "tokenTradeStats")
            TokenTradeStats.internalBinaryWrite(message.userActionKind.tokenTradeStats, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Ping ping = 4; */
        if (message.userActionKind.oneofKind === "ping")
            Ping.internalBinaryWrite(message.userActionKind.ping, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Pong pong = 5; */
        if (message.userActionKind.oneofKind === "pong")
            Pong.internalBinaryWrite(message.userActionKind.pong, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.UserAction
 */
export const UserAction = new UserAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeEventSub$Type extends MessageType<TradeEventSub> {
    constructor() {
        super("cabal.TradeEventSub", []);
    }
    create(value?: PartialMessage<TradeEventSub>): TradeEventSub {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TradeEventSub>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeEventSub): TradeEventSub {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeEventSub, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TradeEventSub
 */
export const TradeEventSub = new TradeEventSub$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserActionSub$Type extends MessageType<UserActionSub> {
    constructor() {
        super("cabal.UserActionSub", []);
    }
    create(value?: PartialMessage<UserActionSub>): UserActionSub {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserActionSub>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserActionSub): UserActionSub {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserActionSub, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.UserActionSub
 */
export const UserActionSub = new UserActionSub$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoRequest$Type extends MessageType<EchoRequest> {
    constructor() {
        super("cabal.EchoRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoRequest>): EchoRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EchoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoRequest): EchoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.EchoRequest
 */
export const EchoRequest = new EchoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EchoResponse$Type extends MessageType<EchoResponse> {
    constructor() {
        super("cabal.EchoResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EchoResponse>): EchoResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<EchoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EchoResponse): EchoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EchoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.EchoResponse
 */
export const EchoResponse = new EchoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeEventRequest$Type extends MessageType<TradeEventRequest> {
    constructor() {
        super("cabal.TradeEventRequest", [
            { no: 1, name: "sub", kind: "message", oneof: "tradeEventRequestKind", T: () => TokenTradeEventSub },
            { no: 2, name: "ping", kind: "message", oneof: "tradeEventRequestKind", T: () => Ping },
            { no: 3, name: "pong", kind: "message", oneof: "tradeEventRequestKind", T: () => Pong }
        ]);
    }
    create(value?: PartialMessage<TradeEventRequest>): TradeEventRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeEventRequestKind = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TradeEventRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeEventRequest): TradeEventRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cabal.TokenTradeEventSub sub */ 1:
                    message.tradeEventRequestKind = {
                        oneofKind: "sub",
                        sub: TokenTradeEventSub.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventRequestKind as any).sub)
                    };
                    break;
                case /* cabal.Ping ping */ 2:
                    message.tradeEventRequestKind = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventRequestKind as any).ping)
                    };
                    break;
                case /* cabal.Pong pong */ 3:
                    message.tradeEventRequestKind = {
                        oneofKind: "pong",
                        pong: Pong.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventRequestKind as any).pong)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeEventRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cabal.TokenTradeEventSub sub = 1; */
        if (message.tradeEventRequestKind.oneofKind === "sub")
            TokenTradeEventSub.internalBinaryWrite(message.tradeEventRequestKind.sub, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Ping ping = 2; */
        if (message.tradeEventRequestKind.oneofKind === "ping")
            Ping.internalBinaryWrite(message.tradeEventRequestKind.ping, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Pong pong = 3; */
        if (message.tradeEventRequestKind.oneofKind === "pong")
            Pong.internalBinaryWrite(message.tradeEventRequestKind.pong, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TradeEventRequest
 */
export const TradeEventRequest = new TradeEventRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenTradeEventSub$Type extends MessageType<TokenTradeEventSub> {
    constructor() {
        super("cabal.TokenTradeEventSub", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenTradeEventSub>): TokenTradeEventSub {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        if (value !== undefined)
            reflectionMergePartial<TokenTradeEventSub>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTradeEventSub): TokenTradeEventSub {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenTradeEventSub, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TokenTradeEventSub
 */
export const TokenTradeEventSub = new TokenTradeEventSub$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenStatusRequest$Type extends MessageType<TokenStatusRequest> {
    constructor() {
        super("cabal.TokenStatusRequest", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenStatusRequest>): TokenStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        if (value !== undefined)
            reflectionMergePartial<TokenStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenStatusRequest): TokenStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TokenStatusRequest
 */
export const TokenStatusRequest = new TokenStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeEventResponse$Type extends MessageType<TradeEventResponse> {
    constructor() {
        super("cabal.TradeEventResponse", [
            { no: 1, name: "trade_event", kind: "message", oneof: "tradeEventResponseKind", T: () => TradeEvent },
            { no: 2, name: "token_status", kind: "message", oneof: "tradeEventResponseKind", T: () => TokenStatus },
            { no: 3, name: "ping", kind: "message", oneof: "tradeEventResponseKind", T: () => Ping },
            { no: 4, name: "pong", kind: "message", oneof: "tradeEventResponseKind", T: () => Pong }
        ]);
    }
    create(value?: PartialMessage<TradeEventResponse>): TradeEventResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeEventResponseKind = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TradeEventResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeEventResponse): TradeEventResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cabal.TradeEvent trade_event */ 1:
                    message.tradeEventResponseKind = {
                        oneofKind: "tradeEvent",
                        tradeEvent: TradeEvent.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventResponseKind as any).tradeEvent)
                    };
                    break;
                case /* cabal.TokenStatus token_status */ 2:
                    message.tradeEventResponseKind = {
                        oneofKind: "tokenStatus",
                        tokenStatus: TokenStatus.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventResponseKind as any).tokenStatus)
                    };
                    break;
                case /* cabal.Ping ping */ 3:
                    message.tradeEventResponseKind = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventResponseKind as any).ping)
                    };
                    break;
                case /* cabal.Pong pong */ 4:
                    message.tradeEventResponseKind = {
                        oneofKind: "pong",
                        pong: Pong.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventResponseKind as any).pong)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeEventResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cabal.TradeEvent trade_event = 1; */
        if (message.tradeEventResponseKind.oneofKind === "tradeEvent")
            TradeEvent.internalBinaryWrite(message.tradeEventResponseKind.tradeEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TokenStatus token_status = 2; */
        if (message.tradeEventResponseKind.oneofKind === "tokenStatus")
            TokenStatus.internalBinaryWrite(message.tradeEventResponseKind.tokenStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Ping ping = 3; */
        if (message.tradeEventResponseKind.oneofKind === "ping")
            Ping.internalBinaryWrite(message.tradeEventResponseKind.ping, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Pong pong = 4; */
        if (message.tradeEventResponseKind.oneofKind === "pong")
            Pong.internalBinaryWrite(message.tradeEventResponseKind.pong, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TradeEventResponse
 */
export const TradeEventResponse = new TradeEventResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ping$Type extends MessageType<Ping> {
    constructor() {
        super("cabal.Ping", [
            { no: 1, name: "count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Ping>): Ping {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<Ping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ping): Ping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 count */ 1:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 count = 1; */
        if (message.count !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.Ping
 */
export const Ping = new Ping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pong$Type extends MessageType<Pong> {
    constructor() {
        super("cabal.Pong", [
            { no: 1, name: "count", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Pong>): Pong {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.count = 0n;
        if (value !== undefined)
            reflectionMergePartial<Pong>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pong): Pong {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 count */ 1:
                    message.count = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pong, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 count = 1; */
        if (message.count !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.Pong
 */
export const Pong = new Pong$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserResponse$Type extends MessageType<UserResponse> {
    constructor() {
        super("cabal.UserResponse", [
            { no: 1, name: "trade_status", kind: "message", oneof: "userResponseKind", T: () => TradeResponse },
            { no: 2, name: "trade_stats", kind: "message", oneof: "userResponseKind", T: () => TokenTradeStats },
            { no: 3, name: "txn_cb", kind: "message", oneof: "userResponseKind", T: () => LandedTxnState },
            { no: 4, name: "ping", kind: "message", oneof: "userResponseKind", T: () => Ping },
            { no: 5, name: "pong", kind: "message", oneof: "userResponseKind", T: () => Pong }
        ]);
    }
    create(value?: PartialMessage<UserResponse>): UserResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userResponseKind = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<UserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserResponse): UserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cabal.TradeResponse trade_status */ 1:
                    message.userResponseKind = {
                        oneofKind: "tradeStatus",
                        tradeStatus: TradeResponse.internalBinaryRead(reader, reader.uint32(), options, (message.userResponseKind as any).tradeStatus)
                    };
                    break;
                case /* cabal.TokenTradeStats trade_stats */ 2:
                    message.userResponseKind = {
                        oneofKind: "tradeStats",
                        tradeStats: TokenTradeStats.internalBinaryRead(reader, reader.uint32(), options, (message.userResponseKind as any).tradeStats)
                    };
                    break;
                case /* txncb.LandedTxnState txn_cb */ 3:
                    message.userResponseKind = {
                        oneofKind: "txnCb",
                        txnCb: LandedTxnState.internalBinaryRead(reader, reader.uint32(), options, (message.userResponseKind as any).txnCb)
                    };
                    break;
                case /* cabal.Ping ping */ 4:
                    message.userResponseKind = {
                        oneofKind: "ping",
                        ping: Ping.internalBinaryRead(reader, reader.uint32(), options, (message.userResponseKind as any).ping)
                    };
                    break;
                case /* cabal.Pong pong */ 5:
                    message.userResponseKind = {
                        oneofKind: "pong",
                        pong: Pong.internalBinaryRead(reader, reader.uint32(), options, (message.userResponseKind as any).pong)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cabal.TradeResponse trade_status = 1; */
        if (message.userResponseKind.oneofKind === "tradeStatus")
            TradeResponse.internalBinaryWrite(message.userResponseKind.tradeStatus, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TokenTradeStats trade_stats = 2; */
        if (message.userResponseKind.oneofKind === "tradeStats")
            TokenTradeStats.internalBinaryWrite(message.userResponseKind.tradeStats, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* txncb.LandedTxnState txn_cb = 3; */
        if (message.userResponseKind.oneofKind === "txnCb")
            LandedTxnState.internalBinaryWrite(message.userResponseKind.txnCb, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Ping ping = 4; */
        if (message.userResponseKind.oneofKind === "ping")
            Ping.internalBinaryWrite(message.userResponseKind.ping, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cabal.Pong pong = 5; */
        if (message.userResponseKind.oneofKind === "pong")
            Pong.internalBinaryWrite(message.userResponseKind.pong, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.UserResponse
 */
export const UserResponse = new UserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenTradeStatsCall$Type extends MessageType<TokenTradeStatsCall> {
    constructor() {
        super("cabal.TokenTradeStatsCall", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenTradeStatsCall>): TokenTradeStatsCall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        if (value !== undefined)
            reflectionMergePartial<TokenTradeStatsCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTradeStatsCall): TokenTradeStatsCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenTradeStatsCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TokenTradeStatsCall
 */
export const TokenTradeStatsCall = new TokenTradeStatsCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeResponse$Type extends MessageType<TradeResponse> {
    constructor() {
        super("cabal.TradeResponse", [
            { no: 2, name: "slot", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TradeResponse>): TradeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slot = 0n;
        if (value !== undefined)
            reflectionMergePartial<TradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeResponse): TradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 slot */ 2:
                    message.slot = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 slot = 2; */
        if (message.slot !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.slot);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TradeResponse
 */
export const TradeResponse = new TradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenStatus$Type extends MessageType<TokenStatus> {
    constructor() {
        super("cabal.TokenStatus", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pool_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pool_kind", kind: "enum", T: () => ["cabal.PoolKind", PoolKind] },
            { no: 4, name: "migration_status", kind: "enum", T: () => ["cabal.MigrationStatus", MigrationStatus] },
            { no: 5, name: "supply", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "base_liq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "quote_liq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "qoute_kind", kind: "enum", T: () => ["common.QuoteKind", QuoteKind] },
            { no: 9, name: "tax_bps", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 10, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenStatus>): TokenStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        message.poolId = "";
        message.poolKind = 0;
        message.migrationStatus = 0;
        message.supply = 0n;
        message.baseLiq = 0n;
        message.quoteLiq = 0n;
        message.qouteKind = 0;
        message.ticker = "";
        if (value !== undefined)
            reflectionMergePartial<TokenStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenStatus): TokenStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                case /* string pool_id */ 2:
                    message.poolId = reader.string();
                    break;
                case /* cabal.PoolKind pool_kind */ 3:
                    message.poolKind = reader.int32();
                    break;
                case /* cabal.MigrationStatus migration_status */ 4:
                    message.migrationStatus = reader.int32();
                    break;
                case /* uint64 supply */ 5:
                    message.supply = reader.uint64().toBigInt();
                    break;
                case /* uint64 base_liq */ 6:
                    message.baseLiq = reader.uint64().toBigInt();
                    break;
                case /* uint64 quote_liq */ 7:
                    message.quoteLiq = reader.uint64().toBigInt();
                    break;
                case /* common.QuoteKind qoute_kind */ 8:
                    message.qouteKind = reader.int32();
                    break;
                case /* optional uint32 tax_bps */ 9:
                    message.taxBps = reader.uint32();
                    break;
                case /* string ticker */ 10:
                    message.ticker = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        /* string pool_id = 2; */
        if (message.poolId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.poolId);
        /* cabal.PoolKind pool_kind = 3; */
        if (message.poolKind !== 0)
            writer.tag(3, WireType.Varint).int32(message.poolKind);
        /* cabal.MigrationStatus migration_status = 4; */
        if (message.migrationStatus !== 0)
            writer.tag(4, WireType.Varint).int32(message.migrationStatus);
        /* uint64 supply = 5; */
        if (message.supply !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.supply);
        /* uint64 base_liq = 6; */
        if (message.baseLiq !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.baseLiq);
        /* uint64 quote_liq = 7; */
        if (message.quoteLiq !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.quoteLiq);
        /* common.QuoteKind qoute_kind = 8; */
        if (message.qouteKind !== 0)
            writer.tag(8, WireType.Varint).int32(message.qouteKind);
        /* optional uint32 tax_bps = 9; */
        if (message.taxBps !== undefined)
            writer.tag(9, WireType.Varint).uint32(message.taxBps);
        /* string ticker = 10; */
        if (message.ticker !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.ticker);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TokenStatus
 */
export const TokenStatus = new TokenStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenTradeStats$Type extends MessageType<TokenTradeStats> {
    constructor() {
        super("cabal.TokenTradeStats", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "buy_qoute", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "sell_qoute", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "buy_base", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "sell_base", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "buys", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "sells", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 9, name: "sol_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "last_traded_slot", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "token_decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 12, name: "qoute_kind", kind: "enum", T: () => ["common.QuoteKind", QuoteKind] }
        ]);
    }
    create(value?: PartialMessage<TokenTradeStats>): TokenTradeStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        message.tokenBalance = 0n;
        message.buyQoute = 0n;
        message.sellQoute = 0n;
        message.buyBase = 0n;
        message.sellBase = 0n;
        message.buys = 0;
        message.sells = 0;
        message.solBalance = 0n;
        message.lastTradedSlot = 0n;
        message.tokenDecimals = 0;
        message.qouteKind = 0;
        if (value !== undefined)
            reflectionMergePartial<TokenTradeStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTradeStats): TokenTradeStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                case /* uint64 token_balance */ 2:
                    message.tokenBalance = reader.uint64().toBigInt();
                    break;
                case /* uint64 buy_qoute */ 3:
                    message.buyQoute = reader.uint64().toBigInt();
                    break;
                case /* uint64 sell_qoute */ 4:
                    message.sellQoute = reader.uint64().toBigInt();
                    break;
                case /* uint64 buy_base */ 5:
                    message.buyBase = reader.uint64().toBigInt();
                    break;
                case /* uint64 sell_base */ 6:
                    message.sellBase = reader.uint64().toBigInt();
                    break;
                case /* uint32 buys */ 7:
                    message.buys = reader.uint32();
                    break;
                case /* uint32 sells */ 8:
                    message.sells = reader.uint32();
                    break;
                case /* uint64 sol_balance */ 9:
                    message.solBalance = reader.uint64().toBigInt();
                    break;
                case /* uint64 last_traded_slot */ 10:
                    message.lastTradedSlot = reader.uint64().toBigInt();
                    break;
                case /* uint32 token_decimals */ 11:
                    message.tokenDecimals = reader.uint32();
                    break;
                case /* common.QuoteKind qoute_kind */ 12:
                    message.qouteKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenTradeStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        /* uint64 token_balance = 2; */
        if (message.tokenBalance !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.tokenBalance);
        /* uint64 buy_qoute = 3; */
        if (message.buyQoute !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.buyQoute);
        /* uint64 sell_qoute = 4; */
        if (message.sellQoute !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.sellQoute);
        /* uint64 buy_base = 5; */
        if (message.buyBase !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.buyBase);
        /* uint64 sell_base = 6; */
        if (message.sellBase !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.sellBase);
        /* uint32 buys = 7; */
        if (message.buys !== 0)
            writer.tag(7, WireType.Varint).uint32(message.buys);
        /* uint32 sells = 8; */
        if (message.sells !== 0)
            writer.tag(8, WireType.Varint).uint32(message.sells);
        /* uint64 sol_balance = 9; */
        if (message.solBalance !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.solBalance);
        /* uint64 last_traded_slot = 10; */
        if (message.lastTradedSlot !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.lastTradedSlot);
        /* uint32 token_decimals = 11; */
        if (message.tokenDecimals !== 0)
            writer.tag(11, WireType.Varint).uint32(message.tokenDecimals);
        /* common.QuoteKind qoute_kind = 12; */
        if (message.qouteKind !== 0)
            writer.tag(12, WireType.Varint).int32(message.qouteKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TokenTradeStats
 */
export const TokenTradeStats = new TokenTradeStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeEvent$Type extends MessageType<TradeEvent> {
    constructor() {
        super("cabal.TradeEvent", [
            { no: 1, name: "buy", kind: "message", oneof: "tradeEventKind", T: () => TradeEventData },
            { no: 2, name: "sell", kind: "message", oneof: "tradeEventKind", T: () => TradeEventData },
            { no: 3, name: "deposit", kind: "message", oneof: "tradeEventKind", T: () => TradeEventData },
            { no: 4, name: "withdraw", kind: "message", oneof: "tradeEventKind", T: () => TradeEventData },
            { no: 5, name: "migration_start", kind: "message", oneof: "tradeEventKind", T: () => TradeEventData },
            { no: 6, name: "migration_end", kind: "message", oneof: "tradeEventKind", T: () => TradeEventData },
            { no: 7, name: "burn_liq", kind: "message", oneof: "tradeEventKind", T: () => BurnEventData },
            { no: 8, name: "burn_mint", kind: "message", oneof: "tradeEventKind", T: () => BurnEventData }
        ]);
    }
    create(value?: PartialMessage<TradeEvent>): TradeEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeEventKind = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TradeEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeEvent): TradeEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* cabal.TradeEventData buy */ 1:
                    message.tradeEventKind = {
                        oneofKind: "buy",
                        buy: TradeEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).buy)
                    };
                    break;
                case /* cabal.TradeEventData sell */ 2:
                    message.tradeEventKind = {
                        oneofKind: "sell",
                        sell: TradeEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).sell)
                    };
                    break;
                case /* cabal.TradeEventData deposit */ 3:
                    message.tradeEventKind = {
                        oneofKind: "deposit",
                        deposit: TradeEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).deposit)
                    };
                    break;
                case /* cabal.TradeEventData withdraw */ 4:
                    message.tradeEventKind = {
                        oneofKind: "withdraw",
                        withdraw: TradeEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).withdraw)
                    };
                    break;
                case /* cabal.TradeEventData migration_start */ 5:
                    message.tradeEventKind = {
                        oneofKind: "migrationStart",
                        migrationStart: TradeEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).migrationStart)
                    };
                    break;
                case /* cabal.TradeEventData migration_end */ 6:
                    message.tradeEventKind = {
                        oneofKind: "migrationEnd",
                        migrationEnd: TradeEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).migrationEnd)
                    };
                    break;
                case /* cabal.BurnEventData burn_liq */ 7:
                    message.tradeEventKind = {
                        oneofKind: "burnLiq",
                        burnLiq: BurnEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).burnLiq)
                    };
                    break;
                case /* cabal.BurnEventData burn_mint */ 8:
                    message.tradeEventKind = {
                        oneofKind: "burnMint",
                        burnMint: BurnEventData.internalBinaryRead(reader, reader.uint32(), options, (message.tradeEventKind as any).burnMint)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* cabal.TradeEventData buy = 1; */
        if (message.tradeEventKind.oneofKind === "buy")
            TradeEventData.internalBinaryWrite(message.tradeEventKind.buy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TradeEventData sell = 2; */
        if (message.tradeEventKind.oneofKind === "sell")
            TradeEventData.internalBinaryWrite(message.tradeEventKind.sell, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TradeEventData deposit = 3; */
        if (message.tradeEventKind.oneofKind === "deposit")
            TradeEventData.internalBinaryWrite(message.tradeEventKind.deposit, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TradeEventData withdraw = 4; */
        if (message.tradeEventKind.oneofKind === "withdraw")
            TradeEventData.internalBinaryWrite(message.tradeEventKind.withdraw, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TradeEventData migration_start = 5; */
        if (message.tradeEventKind.oneofKind === "migrationStart")
            TradeEventData.internalBinaryWrite(message.tradeEventKind.migrationStart, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* cabal.TradeEventData migration_end = 6; */
        if (message.tradeEventKind.oneofKind === "migrationEnd")
            TradeEventData.internalBinaryWrite(message.tradeEventKind.migrationEnd, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* cabal.BurnEventData burn_liq = 7; */
        if (message.tradeEventKind.oneofKind === "burnLiq")
            BurnEventData.internalBinaryWrite(message.tradeEventKind.burnLiq, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* cabal.BurnEventData burn_mint = 8; */
        if (message.tradeEventKind.oneofKind === "burnMint")
            BurnEventData.internalBinaryWrite(message.tradeEventKind.burnMint, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TradeEvent
 */
export const TradeEvent = new TradeEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeEventData$Type extends MessageType<TradeEventData> {
    constructor() {
        super("cabal.TradeEventData", [
            { no: 1, name: "amount_sol", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "base_liq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "quote_liq", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "pool_kind", kind: "enum", T: () => ["cabal.PoolKind", PoolKind] }
        ]);
    }
    create(value?: PartialMessage<TradeEventData>): TradeEventData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amountSol = 0n;
        message.baseLiq = 0n;
        message.quoteLiq = 0n;
        message.poolKind = 0;
        if (value !== undefined)
            reflectionMergePartial<TradeEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeEventData): TradeEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 amount_sol */ 1:
                    message.amountSol = reader.uint64().toBigInt();
                    break;
                case /* uint64 base_liq */ 2:
                    message.baseLiq = reader.uint64().toBigInt();
                    break;
                case /* uint64 quote_liq */ 3:
                    message.quoteLiq = reader.uint64().toBigInt();
                    break;
                case /* cabal.PoolKind pool_kind */ 4:
                    message.poolKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 amount_sol = 1; */
        if (message.amountSol !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.amountSol);
        /* uint64 base_liq = 2; */
        if (message.baseLiq !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.baseLiq);
        /* uint64 quote_liq = 3; */
        if (message.quoteLiq !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.quoteLiq);
        /* cabal.PoolKind pool_kind = 4; */
        if (message.poolKind !== 0)
            writer.tag(4, WireType.Varint).int32(message.poolKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.TradeEventData
 */
export const TradeEventData = new TradeEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BurnEventData$Type extends MessageType<BurnEventData> {
    constructor() {
        super("cabal.BurnEventData", [
            { no: 1, name: "amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "left", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BurnEventData>): BurnEventData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = 0n;
        message.left = 0n;
        if (value !== undefined)
            reflectionMergePartial<BurnEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BurnEventData): BurnEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 amount */ 1:
                    message.amount = reader.uint64().toBigInt();
                    break;
                case /* uint64 left */ 2:
                    message.left = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BurnEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 amount = 1; */
        if (message.amount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.amount);
        /* uint64 left = 2; */
        if (message.left !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.left);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.BurnEventData
 */
export const BurnEventData = new BurnEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Buy$Type extends MessageType<Buy> {
    constructor() {
        super("cabal.Buy", [
            { no: 1, name: "amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "slippage_bps", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "priority_fee", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "nonce", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "slot_latency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "expire_at", kind: "message", T: () => UnixTimestamp },
            { no: 9, name: "qoute_kind", kind: "enum", opt: true, T: () => ["common.QuoteKind", QuoteKind] }
        ]);
    }
    create(value?: PartialMessage<Buy>): Buy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amount = 0n;
        message.mint = "";
        message.slippageBps = 0;
        message.tip = 0n;
        if (value !== undefined)
            reflectionMergePartial<Buy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Buy): Buy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 amount */ 1:
                    message.amount = reader.uint64().toBigInt();
                    break;
                case /* string mint */ 2:
                    message.mint = reader.string();
                    break;
                case /* uint32 slippage_bps */ 3:
                    message.slippageBps = reader.uint32();
                    break;
                case /* uint64 tip */ 4:
                    message.tip = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 priority_fee */ 5:
                    message.priorityFee = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 nonce */ 6:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 slot_latency */ 7:
                    message.slotLatency = reader.uint32();
                    break;
                case /* optional common.UnixTimestamp expire_at */ 8:
                    message.expireAt = UnixTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireAt);
                    break;
                case /* optional common.QuoteKind qoute_kind */ 9:
                    message.qouteKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Buy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 amount = 1; */
        if (message.amount !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.amount);
        /* string mint = 2; */
        if (message.mint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mint);
        /* uint32 slippage_bps = 3; */
        if (message.slippageBps !== 0)
            writer.tag(3, WireType.Varint).uint32(message.slippageBps);
        /* uint64 tip = 4; */
        if (message.tip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.tip);
        /* optional uint64 priority_fee = 5; */
        if (message.priorityFee !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.priorityFee);
        /* optional uint64 nonce = 6; */
        if (message.nonce !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.nonce);
        /* optional uint32 slot_latency = 7; */
        if (message.slotLatency !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.slotLatency);
        /* optional common.UnixTimestamp expire_at = 8; */
        if (message.expireAt)
            UnixTimestamp.internalBinaryWrite(message.expireAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional common.QuoteKind qoute_kind = 9; */
        if (message.qouteKind !== undefined)
            writer.tag(9, WireType.Varint).int32(message.qouteKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.Buy
 */
export const Buy = new Buy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sell$Type extends MessageType<Sell> {
    constructor() {
        super("cabal.Sell", [
            { no: 1, name: "amount_bps", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "slippage_bps", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "tip", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "priority_fee", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "nonce", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "slot_latency", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "expire_at", kind: "message", T: () => UnixTimestamp }
        ]);
    }
    create(value?: PartialMessage<Sell>): Sell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.amountBps = 0;
        message.mint = "";
        message.slippageBps = 0;
        message.tip = 0n;
        if (value !== undefined)
            reflectionMergePartial<Sell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sell): Sell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 amount_bps */ 1:
                    message.amountBps = reader.uint32();
                    break;
                case /* string mint */ 2:
                    message.mint = reader.string();
                    break;
                case /* uint32 slippage_bps */ 3:
                    message.slippageBps = reader.uint32();
                    break;
                case /* uint64 tip */ 4:
                    message.tip = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 priority_fee */ 5:
                    message.priorityFee = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 nonce */ 6:
                    message.nonce = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 slot_latency */ 7:
                    message.slotLatency = reader.uint32();
                    break;
                case /* optional common.UnixTimestamp expire_at */ 8:
                    message.expireAt = UnixTimestamp.internalBinaryRead(reader, reader.uint32(), options, message.expireAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 amount_bps = 1; */
        if (message.amountBps !== 0)
            writer.tag(1, WireType.Varint).uint32(message.amountBps);
        /* string mint = 2; */
        if (message.mint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mint);
        /* uint32 slippage_bps = 3; */
        if (message.slippageBps !== 0)
            writer.tag(3, WireType.Varint).uint32(message.slippageBps);
        /* uint64 tip = 4; */
        if (message.tip !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.tip);
        /* optional uint64 priority_fee = 5; */
        if (message.priorityFee !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.priorityFee);
        /* optional uint64 nonce = 6; */
        if (message.nonce !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.nonce);
        /* optional uint32 slot_latency = 7; */
        if (message.slotLatency !== undefined)
            writer.tag(7, WireType.Varint).uint32(message.slotLatency);
        /* optional common.UnixTimestamp expire_at = 8; */
        if (message.expireAt)
            UnixTimestamp.internalBinaryWrite(message.expireAt, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message cabal.Sell
 */
export const Sell = new Sell$Type();
/**
 * @generated ServiceType for protobuf service cabal.CabalRpc
 */
export const CabalRpc = new ServiceType("cabal.CabalRpc", [
    { name: "UserActivityUni", serverStreaming: true, options: {}, I: UserActionSub, O: UserResponse },
    { name: "TradesUni", serverStreaming: true, options: {}, I: TradeEventSub, O: TradeEventResponse },
    { name: "SubscribeToken", options: {}, I: TokenTradeEventSub, O: TradeResponse },
    { name: "TradePing", options: {}, I: Ping, O: Pong },
    { name: "UserPing", options: {}, I: Ping, O: Pong },
    { name: "MarketSell", options: {}, I: Sell, O: TradeResponse },
    { name: "MarketBuy", options: {}, I: Buy, O: TradeResponse },
    { name: "GetTokenLimitOrders", options: {}, I: TokenAddress, O: TokenLimitOrders },
    { name: "PlaceLimitOrders", options: {}, I: TokenLimitOrders, O: PlaceLimitOrdersResponce },
    { name: "DeleteLimitOrders", options: {}, I: DeleteOrders, O: PlaceLimitOrdersResponce }
]);
