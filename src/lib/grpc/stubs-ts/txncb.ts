// @generated by protobuf-ts 2.10.0
// @generated from protobuf file "txncb.proto" (package "txncb", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { QuoteKind } from "./common";
import { Decimal } from "./common";
import { TokenLamports } from "./common";
/**
 * @generated from protobuf message txncb.LandedTxnState
 */
export interface LandedTxnState {
    /**
     * @generated from protobuf oneof: state_type
     */
    stateType: {
        oneofKind: "failed";
        /**
         * @generated from protobuf field: txncb.Failed failed = 1;
         */
        failed: Failed;
    } | {
        oneofKind: "confirmed";
        /**
         * @generated from protobuf field: txncb.Confirmed confirmed = 2;
         */
        confirmed: Confirmed;
    } | {
        oneofKind: "lost";
        /**
         * @generated from protobuf field: txncb.Lost lost = 3;
         */
        lost: Lost;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message txncb.Lost
 */
export interface Lost {
    /**
     * @generated from protobuf field: repeated string signatures = 1;
     */
    signatures: string[];
    /**
     * @generated from protobuf field: optional int64 order_id = 2;
     */
    orderId?: bigint;
}
/**
 * @generated from protobuf message txncb.Failed
 */
export interface Failed {
    /**
     * @generated from protobuf field: int32 slot_diff = 1;
     */
    slotDiff: number;
    /**
     * @generated from protobuf field: txncb.TxnTips tips = 2;
     */
    tips?: TxnTips;
    /**
     * @generated from protobuf field: uint32 cu = 3;
     */
    cu: number;
    /**
     * @generated from protobuf field: string err = 4;
     */
    err: string;
    /**
     * @generated from protobuf field: string signature = 5;
     */
    signature: string;
    /**
     * @generated from protobuf field: optional int64 order_id = 6;
     */
    orderId?: bigint;
}
/**
 * @generated from protobuf message txncb.Confirmed
 */
export interface Confirmed {
    /**
     * @generated from protobuf field: int32 slot_diff = 1;
     */
    slotDiff: number;
    /**
     * @generated from protobuf field: repeated txncb.ParsedTrade trades = 2;
     */
    trades: ParsedTrade[];
    /**
     * @generated from protobuf field: txncb.TxnTips tips = 3;
     */
    tips?: TxnTips;
    /**
     * @generated from protobuf field: uint32 cu = 4;
     */
    cu: number;
    /**
     * @generated from protobuf field: string signature = 5;
     */
    signature: string;
    /**
     * @generated from protobuf field: optional int64 order_id = 6;
     */
    orderId?: bigint;
}
/**
 * @generated from protobuf message txncb.ParsedTrade
 */
export interface ParsedTrade {
    /**
     * @generated from protobuf oneof: trade_type
     */
    tradeType: {
        oneofKind: "buy";
        /**
         * @generated from protobuf field: txncb.Buy buy = 1;
         */
        buy: Buy;
    } | {
        oneofKind: "sell";
        /**
         * @generated from protobuf field: txncb.Sell sell = 2;
         */
        sell: Sell;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message txncb.Buy
 */
export interface Buy {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string;
    /**
     * @generated from protobuf field: common.TokenLamports base = 3;
     */
    base?: TokenLamports;
    /**
     * @generated from protobuf field: uint64 quote = 4;
     */
    quote: bigint;
    /**
     * @generated from protobuf field: common.Decimal mc = 5;
     */
    mc?: Decimal;
    /**
     * @generated from protobuf field: common.Decimal price = 6;
     */
    price?: Decimal;
    /**
     * @generated from protobuf field: common.QuoteKind qoute_kind = 7;
     */
    qouteKind: QuoteKind;
}
/**
 * @generated from protobuf message txncb.Sell
 */
export interface Sell {
    /**
     * @generated from protobuf field: string mint = 1;
     */
    mint: string;
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string;
    /**
     * @generated from protobuf field: common.TokenLamports tokens = 3;
     */
    tokens?: TokenLamports;
    /**
     * @generated from protobuf field: uint64 quote = 4;
     */
    quote: bigint;
    /**
     * @generated from protobuf field: common.Decimal pnl = 5;
     */
    pnl?: Decimal;
    /**
     * @generated from protobuf field: common.Decimal mc = 6;
     */
    mc?: Decimal;
    /**
     * @generated from protobuf field: common.Decimal price = 7;
     */
    price?: Decimal;
}
/**
 * @generated from protobuf message txncb.TxnTips
 */
export interface TxnTips {
    /**
     * @generated from protobuf field: uint64 priority = 1;
     */
    priority: bigint;
    /**
     * @generated from protobuf field: uint64 jito = 2;
     */
    jito: bigint;
}
/**
 * @generated from protobuf message txncb.TransactionError
 */
export interface TransactionError {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class LandedTxnState$Type extends MessageType<LandedTxnState> {
    constructor() {
        super("txncb.LandedTxnState", [
            { no: 1, name: "failed", kind: "message", oneof: "stateType", T: () => Failed },
            { no: 2, name: "confirmed", kind: "message", oneof: "stateType", T: () => Confirmed },
            { no: 3, name: "lost", kind: "message", oneof: "stateType", T: () => Lost }
        ]);
    }
    create(value?: PartialMessage<LandedTxnState>): LandedTxnState {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stateType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<LandedTxnState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LandedTxnState): LandedTxnState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* txncb.Failed failed */ 1:
                    message.stateType = {
                        oneofKind: "failed",
                        failed: Failed.internalBinaryRead(reader, reader.uint32(), options, (message.stateType as any).failed)
                    };
                    break;
                case /* txncb.Confirmed confirmed */ 2:
                    message.stateType = {
                        oneofKind: "confirmed",
                        confirmed: Confirmed.internalBinaryRead(reader, reader.uint32(), options, (message.stateType as any).confirmed)
                    };
                    break;
                case /* txncb.Lost lost */ 3:
                    message.stateType = {
                        oneofKind: "lost",
                        lost: Lost.internalBinaryRead(reader, reader.uint32(), options, (message.stateType as any).lost)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LandedTxnState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* txncb.Failed failed = 1; */
        if (message.stateType.oneofKind === "failed")
            Failed.internalBinaryWrite(message.stateType.failed, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* txncb.Confirmed confirmed = 2; */
        if (message.stateType.oneofKind === "confirmed")
            Confirmed.internalBinaryWrite(message.stateType.confirmed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* txncb.Lost lost = 3; */
        if (message.stateType.oneofKind === "lost")
            Lost.internalBinaryWrite(message.stateType.lost, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.LandedTxnState
 */
export const LandedTxnState = new LandedTxnState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Lost$Type extends MessageType<Lost> {
    constructor() {
        super("txncb.Lost", [
            { no: 1, name: "signatures", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "order_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Lost>): Lost {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signatures = [];
        if (value !== undefined)
            reflectionMergePartial<Lost>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Lost): Lost {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string signatures */ 1:
                    message.signatures.push(reader.string());
                    break;
                case /* optional int64 order_id */ 2:
                    message.orderId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Lost, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string signatures = 1; */
        for (let i = 0; i < message.signatures.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.signatures[i]);
        /* optional int64 order_id = 2; */
        if (message.orderId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.orderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.Lost
 */
export const Lost = new Lost$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Failed$Type extends MessageType<Failed> {
    constructor() {
        super("txncb.Failed", [
            { no: 1, name: "slot_diff", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "tips", kind: "message", T: () => TxnTips },
            { no: 3, name: "cu", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "err", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Failed>): Failed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slotDiff = 0;
        message.cu = 0;
        message.err = "";
        message.signature = "";
        if (value !== undefined)
            reflectionMergePartial<Failed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Failed): Failed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot_diff */ 1:
                    message.slotDiff = reader.int32();
                    break;
                case /* txncb.TxnTips tips */ 2:
                    message.tips = TxnTips.internalBinaryRead(reader, reader.uint32(), options, message.tips);
                    break;
                case /* uint32 cu */ 3:
                    message.cu = reader.uint32();
                    break;
                case /* string err */ 4:
                    message.err = reader.string();
                    break;
                case /* string signature */ 5:
                    message.signature = reader.string();
                    break;
                case /* optional int64 order_id */ 6:
                    message.orderId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Failed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot_diff = 1; */
        if (message.slotDiff !== 0)
            writer.tag(1, WireType.Varint).int32(message.slotDiff);
        /* txncb.TxnTips tips = 2; */
        if (message.tips)
            TxnTips.internalBinaryWrite(message.tips, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 cu = 3; */
        if (message.cu !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cu);
        /* string err = 4; */
        if (message.err !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.err);
        /* string signature = 5; */
        if (message.signature !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signature);
        /* optional int64 order_id = 6; */
        if (message.orderId !== undefined)
            writer.tag(6, WireType.Varint).int64(message.orderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.Failed
 */
export const Failed = new Failed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Confirmed$Type extends MessageType<Confirmed> {
    constructor() {
        super("txncb.Confirmed", [
            { no: 1, name: "slot_diff", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "trades", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ParsedTrade },
            { no: 3, name: "tips", kind: "message", T: () => TxnTips },
            { no: 4, name: "cu", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "order_id", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Confirmed>): Confirmed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slotDiff = 0;
        message.trades = [];
        message.cu = 0;
        message.signature = "";
        if (value !== undefined)
            reflectionMergePartial<Confirmed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Confirmed): Confirmed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 slot_diff */ 1:
                    message.slotDiff = reader.int32();
                    break;
                case /* repeated txncb.ParsedTrade trades */ 2:
                    message.trades.push(ParsedTrade.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* txncb.TxnTips tips */ 3:
                    message.tips = TxnTips.internalBinaryRead(reader, reader.uint32(), options, message.tips);
                    break;
                case /* uint32 cu */ 4:
                    message.cu = reader.uint32();
                    break;
                case /* string signature */ 5:
                    message.signature = reader.string();
                    break;
                case /* optional int64 order_id */ 6:
                    message.orderId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Confirmed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 slot_diff = 1; */
        if (message.slotDiff !== 0)
            writer.tag(1, WireType.Varint).int32(message.slotDiff);
        /* repeated txncb.ParsedTrade trades = 2; */
        for (let i = 0; i < message.trades.length; i++)
            ParsedTrade.internalBinaryWrite(message.trades[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* txncb.TxnTips tips = 3; */
        if (message.tips)
            TxnTips.internalBinaryWrite(message.tips, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 cu = 4; */
        if (message.cu !== 0)
            writer.tag(4, WireType.Varint).uint32(message.cu);
        /* string signature = 5; */
        if (message.signature !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.signature);
        /* optional int64 order_id = 6; */
        if (message.orderId !== undefined)
            writer.tag(6, WireType.Varint).int64(message.orderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.Confirmed
 */
export const Confirmed = new Confirmed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ParsedTrade$Type extends MessageType<ParsedTrade> {
    constructor() {
        super("txncb.ParsedTrade", [
            { no: 1, name: "buy", kind: "message", oneof: "tradeType", T: () => Buy },
            { no: 2, name: "sell", kind: "message", oneof: "tradeType", T: () => Sell }
        ]);
    }
    create(value?: PartialMessage<ParsedTrade>): ParsedTrade {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.tradeType = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ParsedTrade>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParsedTrade): ParsedTrade {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* txncb.Buy buy */ 1:
                    message.tradeType = {
                        oneofKind: "buy",
                        buy: Buy.internalBinaryRead(reader, reader.uint32(), options, (message.tradeType as any).buy)
                    };
                    break;
                case /* txncb.Sell sell */ 2:
                    message.tradeType = {
                        oneofKind: "sell",
                        sell: Sell.internalBinaryRead(reader, reader.uint32(), options, (message.tradeType as any).sell)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParsedTrade, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* txncb.Buy buy = 1; */
        if (message.tradeType.oneofKind === "buy")
            Buy.internalBinaryWrite(message.tradeType.buy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* txncb.Sell sell = 2; */
        if (message.tradeType.oneofKind === "sell")
            Sell.internalBinaryWrite(message.tradeType.sell, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.ParsedTrade
 */
export const ParsedTrade = new ParsedTrade$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Buy$Type extends MessageType<Buy> {
    constructor() {
        super("txncb.Buy", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "base", kind: "message", T: () => TokenLamports },
            { no: 4, name: "quote", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "mc", kind: "message", T: () => Decimal },
            { no: 6, name: "price", kind: "message", T: () => Decimal },
            { no: 7, name: "qoute_kind", kind: "enum", T: () => ["common.QuoteKind", QuoteKind] }
        ]);
    }
    create(value?: PartialMessage<Buy>): Buy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        message.ticker = "";
        message.quote = 0n;
        message.qouteKind = 0;
        if (value !== undefined)
            reflectionMergePartial<Buy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Buy): Buy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* common.TokenLamports base */ 3:
                    message.base = TokenLamports.internalBinaryRead(reader, reader.uint32(), options, message.base);
                    break;
                case /* uint64 quote */ 4:
                    message.quote = reader.uint64().toBigInt();
                    break;
                case /* common.Decimal mc */ 5:
                    message.mc = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.mc);
                    break;
                case /* common.Decimal price */ 6:
                    message.price = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* common.QuoteKind qoute_kind */ 7:
                    message.qouteKind = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Buy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* common.TokenLamports base = 3; */
        if (message.base)
            TokenLamports.internalBinaryWrite(message.base, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 quote = 4; */
        if (message.quote !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.quote);
        /* common.Decimal mc = 5; */
        if (message.mc)
            Decimal.internalBinaryWrite(message.mc, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* common.Decimal price = 6; */
        if (message.price)
            Decimal.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* common.QuoteKind qoute_kind = 7; */
        if (message.qouteKind !== 0)
            writer.tag(7, WireType.Varint).int32(message.qouteKind);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.Buy
 */
export const Buy = new Buy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sell$Type extends MessageType<Sell> {
    constructor() {
        super("txncb.Sell", [
            { no: 1, name: "mint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ticker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "tokens", kind: "message", T: () => TokenLamports },
            { no: 4, name: "quote", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "pnl", kind: "message", T: () => Decimal },
            { no: 6, name: "mc", kind: "message", T: () => Decimal },
            { no: 7, name: "price", kind: "message", T: () => Decimal }
        ]);
    }
    create(value?: PartialMessage<Sell>): Sell {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mint = "";
        message.ticker = "";
        message.quote = 0n;
        if (value !== undefined)
            reflectionMergePartial<Sell>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sell): Sell {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mint */ 1:
                    message.mint = reader.string();
                    break;
                case /* string ticker */ 2:
                    message.ticker = reader.string();
                    break;
                case /* common.TokenLamports tokens */ 3:
                    message.tokens = TokenLamports.internalBinaryRead(reader, reader.uint32(), options, message.tokens);
                    break;
                case /* uint64 quote */ 4:
                    message.quote = reader.uint64().toBigInt();
                    break;
                case /* common.Decimal pnl */ 5:
                    message.pnl = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.pnl);
                    break;
                case /* common.Decimal mc */ 6:
                    message.mc = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.mc);
                    break;
                case /* common.Decimal price */ 7:
                    message.price = Decimal.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sell, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mint = 1; */
        if (message.mint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mint);
        /* string ticker = 2; */
        if (message.ticker !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ticker);
        /* common.TokenLamports tokens = 3; */
        if (message.tokens)
            TokenLamports.internalBinaryWrite(message.tokens, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 quote = 4; */
        if (message.quote !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.quote);
        /* common.Decimal pnl = 5; */
        if (message.pnl)
            Decimal.internalBinaryWrite(message.pnl, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* common.Decimal mc = 6; */
        if (message.mc)
            Decimal.internalBinaryWrite(message.mc, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* common.Decimal price = 7; */
        if (message.price)
            Decimal.internalBinaryWrite(message.price, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.Sell
 */
export const Sell = new Sell$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxnTips$Type extends MessageType<TxnTips> {
    constructor() {
        super("txncb.TxnTips", [
            { no: 1, name: "priority", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "jito", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TxnTips>): TxnTips {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.priority = 0n;
        message.jito = 0n;
        if (value !== undefined)
            reflectionMergePartial<TxnTips>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxnTips): TxnTips {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 priority */ 1:
                    message.priority = reader.uint64().toBigInt();
                    break;
                case /* uint64 jito */ 2:
                    message.jito = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxnTips, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 priority = 1; */
        if (message.priority !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.priority);
        /* uint64 jito = 2; */
        if (message.jito !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.jito);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.TxnTips
 */
export const TxnTips = new TxnTips$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionError$Type extends MessageType<TransactionError> {
    constructor() {
        super("txncb.TransactionError", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionError>): TransactionError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<TransactionError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionError): TransactionError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message txncb.TransactionError
 */
export const TransactionError = new TransactionError$Type();
